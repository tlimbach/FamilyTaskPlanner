{"version":3,"file":"runtime.min.js","sources":["../src/index.ts"],"sourcesContent":["import {\n\tsignal,\n\tcomputed,\n\teffect,\n\tSignal,\n\tReadonlySignal,\n\tSignalOptions,\n\tEffectOptions,\n} from \"@preact/signals-core\";\nimport {\n\tuseRef,\n\tuseMemo,\n\tuseEffect,\n\tuseLayoutEffect,\n\tversion as reactVersion,\n} from \"react\";\nimport { useSyncExternalStore } from \"use-sync-external-store/shim/index.js\";\n\nconst [major] = reactVersion.split(\".\").map(Number);\nconst Empty = [] as const;\n// V19 https://github.com/facebook/react/blob/346c7d4c43a0717302d446da9e7423a8e28d8996/packages/shared/ReactSymbols.js#L15\n// V18 https://github.com/facebook/react/blob/346c7d4c43a0717302d446da9e7423a8e28d8996/packages/shared/ReactSymbols.js#L15\nconst ReactElemType = Symbol.for(\n\tmajor >= 19 ? \"react.transitional.element\" : \"react.element\"\n);\n\nexport function wrapJsx<T>(jsx: T): T {\n\tif (typeof jsx !== \"function\") return jsx;\n\n\treturn function (type: any, props: any, ...rest: any[]) {\n\t\tif (typeof type === \"string\" && props) {\n\t\t\tfor (let i in props) {\n\t\t\t\tlet v = props[i];\n\t\t\t\tif (i !== \"children\" && v instanceof Signal) {\n\t\t\t\t\tprops[i] = v.value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jsx.call(jsx, type, props, ...rest);\n\t} as any as T;\n}\n\nconst symDispose: unique symbol =\n\t(Symbol as any).dispose || Symbol.for(\"Symbol.dispose\");\n\ninterface Effect {\n\t_sources: object | undefined;\n\t_start(): () => void;\n\t_callback(): void;\n\t_dispose(): void;\n}\n\n/**\n * Use this flag to represent a bare `useSignals` call that doesn't manually\n * close its effect store and relies on auto-closing when the next useSignals is\n * called or after a microtask\n */\nconst UNMANAGED = 0;\n/**\n * Use this flag to represent a `useSignals` call that is manually closed by a\n * try/finally block in a component's render method. This is the default usage\n * that the react-transform plugin uses.\n */\nconst MANAGED_COMPONENT = 1;\n/**\n * Use this flag to represent a `useSignals` call that is manually closed by a\n * try/finally block in a hook body. This is the default usage that the\n * react-transform plugin uses.\n */\nconst MANAGED_HOOK = 2;\n\n/**\n * An enum defining how this store is used. See the documentation for each enum\n * member for more details.\n * @see {@link UNMANAGED}\n * @see {@link MANAGED_COMPONENT}\n * @see {@link MANAGED_HOOK}\n */\ntype EffectStoreUsage =\n\t| typeof UNMANAGED\n\t| typeof MANAGED_COMPONENT\n\t| typeof MANAGED_HOOK;\n\nexport interface EffectStore {\n\t/**\n\t * An enum defining how this hook is used and whether it is invoked in a\n\t * component's body or hook body. See the comment on `EffectStoreUsage` for\n\t * more details.\n\t */\n\treadonly _usage: EffectStoreUsage;\n\treadonly effect: Effect;\n\tsubscribe(onStoreChange: () => void): () => void;\n\tgetSnapshot(): number;\n\t/** startEffect - begin tracking signals used in this component */\n\t_start(): void;\n\t/** finishEffect - stop tracking the signals used in this component */\n\tf(): void;\n\t[symDispose](): void;\n}\n\nlet currentStore: EffectStore | undefined;\n\nfunction startComponentEffect(\n\tprevStore: EffectStore | undefined,\n\tnextStore: EffectStore\n) {\n\tconst endEffect = nextStore.effect._start();\n\tcurrentStore = nextStore;\n\n\treturn finishComponentEffect.bind(nextStore, prevStore, endEffect);\n}\n\nfunction finishComponentEffect(\n\tthis: EffectStore,\n\tprevStore: EffectStore | undefined,\n\tendEffect: () => void\n) {\n\tendEffect();\n\tcurrentStore = prevStore;\n}\n\n/**\n * A redux-like store whose store value is a positive 32bit integer (a\n * 'version').\n *\n * React subscribes to this store and gets a snapshot of the current 'version',\n * whenever the 'version' changes, we tell React it's time to update the\n * component (call 'onStoreChange').\n *\n * How we achieve this is by creating a binding with an 'effect', when the\n * `effect._callback' is called, we update our store version and tell React to\n * re-render the component ([1] We don't really care when/how React does it).\n *\n * [1]\n * @see https://react.dev/reference/react/useSyncExternalStore\n * @see\n * https://github.com/reactjs/rfcs/blob/main/text/0214-use-sync-external-store.md\n *\n * @param _usage An enum defining how this hook is used and whether it is\n * invoked in a component's body or hook body. See the comment on\n * `EffectStoreUsage` for more details.\n */\nfunction createEffectStore(_usage: EffectStoreUsage): EffectStore {\n\tlet effectInstance!: Effect;\n\tlet endEffect: (() => void) | undefined;\n\tlet version = 0;\n\tlet onChangeNotifyReact: (() => void) | undefined;\n\n\tlet unsubscribe = effect(function (this: Effect) {\n\t\teffectInstance = this;\n\t});\n\teffectInstance._callback = function () {\n\t\tversion = (version + 1) | 0;\n\t\tif (onChangeNotifyReact) onChangeNotifyReact();\n\t};\n\n\treturn {\n\t\t_usage,\n\t\teffect: effectInstance,\n\t\tsubscribe(onStoreChange) {\n\t\t\tonChangeNotifyReact = onStoreChange;\n\n\t\t\treturn function () {\n\t\t\t\t/**\n\t\t\t\t * Rotate to next version when unsubscribing to ensure that components are re-run\n\t\t\t\t * when subscribing again.\n\t\t\t\t *\n\t\t\t\t * In StrictMode, 'memo'-ed components seem to keep a stale snapshot version, so\n\t\t\t\t * don't re-run after subscribing again if the version is the same as last time.\n\t\t\t\t *\n\t\t\t\t * Because we unsubscribe from the effect, the version may not change. We simply\n\t\t\t\t * set a new initial version in case of stale snapshots here.\n\t\t\t\t */\n\t\t\t\tversion = (version + 1) | 0;\n\t\t\t\tonChangeNotifyReact = undefined;\n\t\t\t\tunsubscribe();\n\t\t\t};\n\t\t},\n\t\tgetSnapshot() {\n\t\t\treturn version;\n\t\t},\n\t\t_start() {\n\t\t\t// In general, we want to support two kinds of usages of useSignals:\n\t\t\t//\n\t\t\t// A) Managed: calling useSignals in a component or hook body wrapped in a\n\t\t\t//    try/finally (like what the react-transform plugin does)\n\t\t\t//\n\t\t\t// B) Unmanaged: Calling useSignals directly without wrapping in a\n\t\t\t//    try/finally\n\t\t\t//\n\t\t\t// For managed, we finish the effect in the finally block of the component\n\t\t\t// or hook body. For unmanaged, we finish the effect in the next\n\t\t\t// useSignals call or after a microtask.\n\t\t\t//\n\t\t\t// There are different tradeoffs which each approach. With managed, using\n\t\t\t// a try/finally ensures that only signals used in the component or hook\n\t\t\t// body are tracked. However, signals accessed in render props are missed\n\t\t\t// because the render prop is invoked in another component that may or may\n\t\t\t// not realize it is rendering signals accessed in the render prop it is\n\t\t\t// given.\n\t\t\t//\n\t\t\t// The other approach is \"unmanaged\": to call useSignals directly without\n\t\t\t// wrapping in a try/finally. This approach is easier to manually write in\n\t\t\t// situations where a build step isn't available but does open up the\n\t\t\t// possibility of catching signals accessed in other code before the\n\t\t\t// effect is closed (e.g. in a layout effect). Most situations where this\n\t\t\t// could happen are generally consider bad patterns or bugs. For example,\n\t\t\t// using a signal in a component and not having a call to `useSignals`\n\t\t\t// would be an bug. Or using a signal in `useLayoutEffect` is generally\n\t\t\t// not recommended since that layout effect won't update when the signals'\n\t\t\t// value change.\n\t\t\t//\n\t\t\t// To support both approaches, we need to track how each invocation of\n\t\t\t// useSignals is used, so we can properly transition between different\n\t\t\t// kinds of usages.\n\t\t\t//\n\t\t\t// The following table shows the different scenarios and how we should\n\t\t\t// handle them.\n\t\t\t//\n\t\t\t// Key:\n\t\t\t// 0 = UNMANAGED\n\t\t\t// 1 = MANAGED_COMPONENT\n\t\t\t// 2 = MANAGED_HOOK\n\t\t\t//\n\t\t\t// Pattern:\n\t\t\t// prev store usage -> this store usage: action to take\n\t\t\t//\n\t\t\t// - 0 -> 0: finish previous effect (unknown to unknown)\n\t\t\t//\n\t\t\t//   We don't know how the previous effect was used, so we need to finish\n\t\t\t//   it before starting the next effect.\n\t\t\t//\n\t\t\t// - 0 -> 1: finish previous effect\n\t\t\t//\n\t\t\t//   Assume previous invocation was another component or hook from another\n\t\t\t//   component. Nested component renders (renderToStaticMarkup within a\n\t\t\t//   component's render) won't be supported with bare useSignals calls.\n\t\t\t//\n\t\t\t// - 0 -> 2: capture & restore\n\t\t\t//\n\t\t\t//   Previous invocation could be a component or a hook. Either way,\n\t\t\t//   restore it after our invocation so that it can continue to capture\n\t\t\t//   any signals after we exit.\n\t\t\t//\n\t\t\t// - 1 -> 0: Do nothing. Signals already captured by current effect store\n\t\t\t// - 1 -> 1: capture & restore (e.g. component calls renderToStaticMarkup)\n\t\t\t// - 1 -> 2: capture & restore (e.g. hook)\n\t\t\t//\n\t\t\t// - 2 -> 0: Do nothing. Signals already captured by current effect store\n\t\t\t// - 2 -> 1: capture & restore (e.g. hook calls renderToStaticMarkup)\n\t\t\t// - 2 -> 2: capture & restore (e.g. nested hook calls)\n\n\t\t\tif (currentStore == undefined) {\n\t\t\t\tendEffect = startComponentEffect(undefined, this);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst prevUsage = currentStore._usage;\n\t\t\tconst thisUsage = this._usage;\n\n\t\t\tif (\n\t\t\t\t(prevUsage == UNMANAGED && thisUsage == UNMANAGED) || // 0 -> 0\n\t\t\t\t(prevUsage == UNMANAGED && thisUsage == MANAGED_COMPONENT) // 0 -> 1\n\t\t\t) {\n\t\t\t\t// finish previous effect\n\t\t\t\tcurrentStore.f();\n\t\t\t\tendEffect = startComponentEffect(undefined, this);\n\t\t\t} else if (\n\t\t\t\t(prevUsage == MANAGED_COMPONENT && thisUsage == UNMANAGED) || // 1 -> 0\n\t\t\t\t(prevUsage == MANAGED_HOOK && thisUsage == UNMANAGED) // 2 -> 0\n\t\t\t) {\n\t\t\t\t// Do nothing since it'll be captured by current effect store\n\t\t\t} else {\n\t\t\t\t// nested scenarios, so capture and restore the previous effect store\n\t\t\t\tendEffect = startComponentEffect(currentStore, this);\n\t\t\t}\n\t\t},\n\t\tf() {\n\t\t\tconst end = endEffect;\n\t\t\tendEffect = undefined;\n\t\t\tend?.();\n\t\t},\n\t\t[symDispose]() {\n\t\t\tthis.f();\n\t\t},\n\t};\n}\n\nconst noop = () => {};\n\nfunction createEmptyEffectStore(): EffectStore {\n\treturn {\n\t\t_usage: UNMANAGED,\n\t\teffect: {\n\t\t\t_sources: undefined,\n\t\t\t_callback() {},\n\t\t\t_start() {\n\t\t\t\treturn /* endEffect */ noop;\n\t\t\t},\n\t\t\t_dispose() {},\n\t\t},\n\t\tsubscribe() {\n\t\t\treturn /* unsubscribe */ noop;\n\t\t},\n\t\tgetSnapshot() {\n\t\t\treturn 0;\n\t\t},\n\t\t_start() {},\n\t\tf() {},\n\t\t[symDispose]() {},\n\t};\n}\n\nconst emptyEffectStore = createEmptyEffectStore();\n\nconst _queueMicroTask = Promise.prototype.then.bind(Promise.resolve());\n\nlet finalCleanup: Promise<void> | undefined;\nexport function ensureFinalCleanup() {\n\tif (!finalCleanup) {\n\t\tfinalCleanup = _queueMicroTask(cleanupTrailingStore);\n\t}\n}\nfunction cleanupTrailingStore() {\n\tfinalCleanup = undefined;\n\tcurrentStore?.f();\n}\n\nconst useIsomorphicLayoutEffect =\n\ttypeof window !== \"undefined\" ? useLayoutEffect : useEffect;\n\n/**\n * Custom hook to create the effect to track signals used during render and\n * subscribe to changes to rerender the component when the signals change.\n */\nexport function _useSignalsImplementation(\n\t_usage: EffectStoreUsage = UNMANAGED\n): EffectStore {\n\tensureFinalCleanup();\n\n\tconst storeRef = useRef<EffectStore>();\n\tif (storeRef.current == null) {\n\t\tif (typeof window === \"undefined\") {\n\t\t\tstoreRef.current = emptyEffectStore;\n\t\t} else {\n\t\t\tstoreRef.current = createEffectStore(_usage);\n\t\t}\n\t}\n\n\tconst store = storeRef.current;\n\tuseSyncExternalStore(store.subscribe, store.getSnapshot, store.getSnapshot);\n\tstore._start();\n\t// note: _usage is a constant here, so conditional is okay\n\tif (_usage === UNMANAGED) useIsomorphicLayoutEffect(cleanupTrailingStore);\n\n\treturn store;\n}\n\n/**\n * A wrapper component that renders a Signal's value directly as a Text node or JSX.\n */\nfunction SignalValue({ data }: { data: Signal }) {\n\tconst store = _useSignalsImplementation(1);\n\ttry {\n\t\treturn data.value;\n\t} finally {\n\t\tstore.f();\n\t}\n}\n\n// Decorate Signals so React renders them as <SignalValue> components.\nObject.defineProperties(Signal.prototype, {\n\t$$typeof: { configurable: true, value: ReactElemType },\n\ttype: { configurable: true, value: SignalValue },\n\tprops: {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn { data: this };\n\t\t},\n\t},\n\tref: { configurable: true, value: null },\n});\n\nexport function useSignals(usage?: EffectStoreUsage): EffectStore {\n\treturn _useSignalsImplementation(usage);\n}\n\nexport function useSignal<T>(value: T, options?: SignalOptions<T>): Signal<T>;\nexport function useSignal<T = undefined>(): Signal<T | undefined>;\nexport function useSignal<T>(value?: T, options?: SignalOptions<T>) {\n\treturn useMemo(\n\t\t() => signal<T | undefined>(value, options as SignalOptions),\n\t\tEmpty\n\t);\n}\n\nexport function useComputed<T>(\n\tcompute: () => T,\n\toptions?: SignalOptions<T>\n): ReadonlySignal<T> {\n\tconst $compute = useRef(compute);\n\t$compute.current = compute;\n\treturn useMemo(() => computed<T>(() => $compute.current(), options), Empty);\n}\n\nexport function useSignalEffect(\n\tcb: () => void | (() => void),\n\toptions?: EffectOptions\n) {\n\tconst callback = useRef(cb);\n\tcallback.current = cb;\n\n\tuseEffect(() => {\n\t\treturn effect(function (this: Effect) {\n\t\t\treturn callback.current();\n\t\t}, options);\n\t}, Empty);\n}\n"],"names":["currentStore","major","reactVersion","split","map","Number","Empty","ReactElemType","Symbol","symDispose","dispose","startComponentEffect","prevStore","nextStore","endEffect","effect","_start","finishComponentEffect","bind","_ref2","finalCleanup","noop","emptyEffectStore","_usage","_sources","undefined","_callback","_dispose","subscribe","getSnapshot","f","_queueMicroTask","Promise","prototype","then","resolve","ensureFinalCleanup","cleanupTrailingStore","_currentStore","useIsomorphicLayoutEffect","window","useLayoutEffect","useEffect","_useSignalsImplementation","storeRef","useRef","current","_ref","effectInstance","onChangeNotifyReact","version","unsubscribe","this","onStoreChange","prevUsage","thisUsage","end","createEffectStore","store","useSyncExternalStore","Object","defineProperties","Signal","$$typeof","configurable","value","type","_ref3","data","props","get","ref","exports","useComputed","compute","options","$compute","useMemo","computed","useSignal","signal","useSignalEffect","cb","callback","useSignals","usage","wrapJsx","jsx","i","v","call","apply","concat","slice","arguments"],"mappings":"mcAkBA,IAmFIA,EAnFGC,EAASC,EAAAA,QAAaC,MAAM,KAAKC,IAAIC,QAAhC,GACNC,EAAQ,GAGRC,EAAgBC,OAAM,IAC3BP,GAAS,GAAK,6BAA+B,iBAoBxCQ,EACJD,OAAeE,SAAWF,OAAU,IAAC,kBA2DvC,SAASG,EACRC,EACAC,GAEA,IAAMC,EAAYD,EAAUE,OAAOC,IACnChB,EAAea,EAEf,OAAOI,EAAsBC,KAAKL,EAAWD,EAAWE,EACzD,CAEA,SAASG,EAERL,EACAE,GAEAA,IACAd,EAAeY,CAChB,CAyKA,IAE+BO,EA2B3BC,EA7BEC,EAAO,WAAQ,EAyBfC,IAtBLH,EACCI,CAAAA,EA3OgB,EA4OhBR,OAAQ,CACPS,OAAUC,EACVC,EAAS,aACTV,EAAM,WACL,OAAuBK,CACxB,EACAM,EAAQ,cAETC,UAAA,WACC,OAAyBP,CAC1B,EACAQ,YAAW,WACV,OACD,CAAA,EACAb,EAAA,WAAW,EACXc,EAAA,eACCrB,GAAU,WAAM,EAAAU,GAMbY,EAAkBC,QAAQC,UAAUC,KAAKhB,KAAKc,QAAQG,WAG5C,SAAAC,IACf,IAAKhB,EACJA,EAAeW,EAAgBM,EAEjC,CACA,SAASA,IAAoB,IAAAC,EAC5BlB,OAAeK,EACH,OAAZa,EAAAtC,IAAAsC,EAAcR,GACf,CAEA,IAAMS,EACa,oBAAXC,OAAyBC,EAAAA,gBAAkBC,EAAAA,UAMnC,SAAAC,EACfpB,GAAAA,YAAAA,EAAAA,EAvRiB,EAyRjBa,IAEA,IAAMQ,EAAWC,WACjB,GAAwB,MAApBD,EAASE,QACZ,GAAsB,oBAAXN,OACVI,EAASE,QAAUxB,OAEnBsB,EAASE,QA3MZ,SAA2BvB,GAAwB,IAAAwB,EAC9CC,EACAlC,EAEAmC,EADAC,EAAU,EAGVC,EAAcpC,EAAAA,OAAO,WACxBiC,EAAiBI,IAClB,GACAJ,EAAetB,EAAY,WAC1BwB,EAAWA,EAAU,EAAK,EAC1B,GAAID,EAAqBA,GAC1B,EAEA,OAAAF,EAAA,CACCxB,EAAAA,EACAR,OAAQiC,EACRpB,UAAA,SAAUyB,GACTJ,EAAsBI,EAEtB,OAAO,WAWNH,EAAWA,EAAU,EAAK,EAC1BD,OAAsBxB,EACtB0B,GACD,CACD,EACAtB,YAAW,WACV,OAAOqB,CACR,EACAlC,EAAA,WAuEC,GAAoBS,MAAhBzB,EAAJ,CAKA,IAAMsD,EAAYtD,EAAauB,EACzBgC,EAAYH,KAAK7B,EAEvB,GA3Me,GA4Mb+B,GA5Ma,GA4MaC,GA5Mb,GA6MbD,GAvMqB,GAuMKC,EAC1B,CAEDvD,EAAa8B,IACbhB,EAAYH,OAAqBc,EAAW2B,KAC7C,MAAO,GA5MgB,GA6MrBE,GAnNa,GAmNqBC,GAvMlB,GAwMhBD,GApNa,GAoNgBC,QAK9BzC,EAAYH,EAAqBX,EAAcoD,KAnBhD,MAFCtC,EAAYH,OAAqBc,EAAW2B,KAuB9C,EACAtB,EAAA,WACC,IAAM0B,EAAM1C,EACZA,OAAYW,EACZ+B,MAAAA,GAAAA,GACD,IACC/C,GAAU,WACV2C,KAAKtB,GACN,EAACiB,CAEH,CA2DsBU,CAAkBlC,GAIvC,IAAMmC,EAAQd,EAASE,QACvBa,EAAAA,qBAAqBD,EAAM9B,UAAW8B,EAAM7B,YAAa6B,EAAM7B,aAC/D6B,EAAM1C,IAEN,GAxSiB,IAwSbO,EAAsBgB,EAA0BF,GAEpD,OAAOqB,CACR,CAeAE,OAAOC,iBAAiBC,EAAAA,OAAO7B,UAAW,CACzC8B,SAAU,CAAEC,cAAc,EAAMC,MAAO1D,GACvC2D,KAAM,CAAEF,cAAc,EAAMC,MAZ7B,SAAoBE,GAAG,IAAAC,EAAID,EAAJC,KAChBV,EAAQf,EAA0B,GACxC,IACC,OAAOyB,EAAKH,KAGb,CAFC,QACAP,EAAM5B,GACP,CACD,GAMCuC,MAAO,CACNL,cAAc,EACdM,IAAA,WACC,MAAO,CAAEF,KAAMhB,KAChB,GAEDmB,IAAK,CAAEP,cAAc,EAAMC,MAAO,QAqCnCO,EAAA7B,EAAAA,EAAA6B,EAAApC,mBAAAA,EAAAoC,EAAAC,YArBgB,SACfC,EACAC,GAEA,IAAMC,EAAW/B,EAAMA,OAAC6B,GACxBE,EAAS9B,QAAU4B,EACnB,OAAOG,EAAOA,QAAC,WAAA,OAAMC,EAAAA,SAAY,WAAA,OAAMF,EAAS9B,SAAS,EAAE6B,EAAQ,EAAErE,EACtE,EAcAkE,EAAAO,UA5BgB,SAAad,EAAWU,GACvC,OAAOE,EAAOA,QACb,WAAA,OAAMG,EAAAA,OAAsBf,EAAOU,EAAyB,EAC5DrE,EAEF,EAuBAkE,EAAAS,gBAZgB,SACfC,EACAP,GAEA,IAAMQ,EAAWtC,EAAAA,OAAOqC,GACxBC,EAASrC,QAAUoC,EAEnBxC,EAAAA,UAAU,WACT,OAAO3B,EAAMA,OAAC,WACb,OAAOoE,EAASrC,SACjB,EAAG6B,EACJ,EAAGrE,EACJ,EAAAkE,EAAAY,WAlCgB,SAAWC,GAC1B,OAAO1C,EAA0B0C,EAClC,EAgCAb,EAAAc,QAxYgB,SAAWC,GAC1B,GAAmB,mBAARA,EAAoB,OAAOA,OAEtC,OAAiBrB,SAAAA,EAAWG,GAC3B,GAAoB,iBAATH,GAAqBG,EAC/B,IAAK,IAAImB,KAAKnB,EAAO,CACpB,IAAIoB,EAAIpB,EAAMmB,GACd,GAAU,aAANA,GAAoBC,aAAa3B,EAAAA,OACpCO,EAAMmB,GAAKC,EAAExB,KAEf,CAGD,OAAOsB,EAAIG,KAAIC,MAARJ,EAAG,CAAMA,EAAKrB,EAAMG,GAAKuB,OAAAC,GAAAA,MAAAH,KAAAI,UAAS,IAC1C,CACD,CAyXA"}